<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="代写完成–Java 算法: 匿名通信算法

Network NodesFollowing is a description adapted from Rass and Wigoutschnigg [2016]. For the purposes of sending a message, there are three kinds of nodes: the initiator, intermediate forwarding nodes, and the receiver. The N nodes of a network will be identiﬁed by integers 0, 1, 2, 3 . . . N − 1. 
The protocol is, however, still vulnerable to attack by a local eavesdropper (an attacker that can observe all incoming and outgoing messages for any proper subset of the nodes) or an attack known as the predecessor attack.">
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="The Deterministic Crowds Protocol"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>The Deterministic Crowds Protocol - Hexo</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="stylesheet" href="/css/main.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!--Favicon-->
    

</head>

<body>

<!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">Hexo</a>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">主页</a>
            </li>
            
            <li>
                <a href="/archives">档案</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class="social clearfix">
            
            
                <li><a href="https://www.facebook.com/" class="fb" target="_blank" data-title="Facebook"></a></li>
            
            
                <li><a href="https://www.behance.net/" class="behance" target="_blank" data-title="Behance"></a></li>
            
            
                <li><a href="https://plus.google.com/+Pixelhint/posts" class="google" target="_blank" data-title="Google+"></a></li>
            
            
                <li><a href="https://dribbble.com/pixelhint" class="dribble" target="_blank" data-title="Dribble"></a></li>
            
            
            
            
        </ul><!-- end social -->

        <div class="rights">
            <p>Copyright © 2014 magnetic.</p>
            <p>Template by <a href="http://pixelhint.com/magnetic-free-html5-responsive-photography-website-template/" target="_blank" rel="noopener">Pixelhint.com</a></p>
            <p>Hexo Theme by <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan K.</a></p>
        </div><!-- end rights -->
    </div ><!-- end footer -->
</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('http://placehold.it/1300x500');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a href="/2019/09/06/biological%20family%20trees/" class="previous" data-title="biological family trees"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2018/09/18/Sudoku/" class="next" data-title="Sudoku"></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">The Deterministic Crowds Protocol</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <hr>
<p>代写完成–Java 算法: 匿名通信算法</p>
<hr>
<h5 id="Network-Nodes"><a href="#Network-Nodes" class="headerlink" title="Network Nodes"></a>Network Nodes</h5><p>Following is a description adapted from Rass and Wigoutschnigg [2016]. For the purposes of sending a message, there are three kinds of nodes: the initiator, intermediate forwarding nodes, and the receiver. The N nodes of a network will be identiﬁed by integers <code>0, 1, 2, 3 . . . N − 1</code>. </p>
<p>The protocol is, however, still vulnerable to attack by a local eavesdropper (an attacker that can observe all incoming and outgoing messages for any proper subset of the nodes) or an attack known as the predecessor attack.</p>
<a id="more"></a>
<p>Initiator We will call the initiating node $v_0$ . There will be a function $f : N → N$, taking a non-negative integer and producing non-negative integer, that a node will use to decide which node it will send a message to. (Notationally, $f^{−1}$ will be the inverse of this function.)</p>
<p>To transmit a message m to a receiver v, $v_0$ ﬁrst chooses a path length n and calls $v_n := v$ the receiver. It then goes on to choose a value $r_n ≡ v_n  mod  N$, and backward iterates $r_{n−1} = f^{−1} (r_n)$ until it reaches a value $r_1$ . The ﬁrst node to transmit the payload to (where the payload consists of the message m, value r and function f) is thus $v_1 = r_1 mod N$, and the initiator acts just as if it would have if it had computed $r_1$ from the data being sent from elsewhere to $v_0$ .</p>
<p>Question: If there is such a function $f^{−1}$ , how can the protocol prevent any node from tracking the message back? The solution is for f to be a trapdoor function, one whose inverse can only (easily) be calculated by using a trapdoor secret. §2.2 explains these and gives an example of how it is applied here.</p>
<p>Forwarding Node Forwarding node $v_i$ , upon receiving the message m, along with a value $r_i$ and a function f, ﬁrst checks if it is the designated receiver. As it is not, it computes $r_{i+1} = f(r_i)$ and thence the next hop as $v_{i+1} = r_{i+1} mod N$, and sends the message m together with $r_{i+1}$ and f to $v_{i+1}$ .</p>
<p>Receiver Node $v_n$ similarly checks if it is the designated receiver. As it is, the process stops.</p>
<p>2.2 Trapdoor Functions</p>
<p>An Example of a Trapdoor Function Trapdoor functions are used widely in cryptography. The kind of function we’ll be using comes from RSA encryption. 5 There are three values that we’ll be using to deﬁne our function f and its inverse $f^{−1}$ ; we’ll call these e, d and K. e and K will be used to deﬁne f, which will be public; d will be the trapdoor secret.</p>
<p>Our public function will be</p>
<p>$$f(x) = x^e mod K  (1)$$</p>
<p>and our inverting function will be</p>
<p>$$g(x) = x^d mod K (2)$$</p>
<p>There is a process (in cryptography, a key generation algorithm) to ﬁnd values of e, d, K such that $f(g(x)) = x$, i.e. $g(x) = f^{−1} (x)$.</p>
<p>Consider e = 3, d = 7, K = 33. Then, $f(30) = 30^3 mod 33 = 6$. To compute the inverse, $f^{−1} (6) = g(6) = 6^7 mod 33 = 30$. This inverse can only (easily) be computed if d is known.</p>
<p>Applying a Trapdoor to Deterministic Crowds Consider a network (crowd) with nodes 0 . . . 19. Let the message initiator be node $v_0 = 1$. $v_0$ decides on a path length of n = 3 (i.e. via two intermediate forwarding nodes) to send its message to receiver node $v = v_3 = 6$. It makes the following calculations:</p>
<p>$1. r_3 = 6.$</p>
<p>$2. r_2 = f^{−1} (6) = 6^7 mod 33 = 30.$</p>
<p>This corresponds to node $v_2 = r_2 mod N = 30 mod 20 = 10$.</p>
<p>$3. r_1 = f^{−1} (30) = 30^7 mod 33 = 24.$</p>
<p>This corresponds to node $v_1 = r_1 mod N = 24 mod 20 = 4$.</p>
<p>So the node that $v_0$ forwards the message to, along with the value $r_1 = 24$ and function f (but not $f^{−1}$ or the value d that would allow $f^{−1}$ to be calculated), is node 4.The full path will be 1 → 4 → 10 → 6.</p>
<h5 id="Assignment-Code-Structure"><a href="#Assignment-Code-Structure" class="headerlink" title="Assignment Code Structure"></a>Assignment Code Structure</h5><p>You will be working with a Java project that has 4 classes:</p>
<ul>
<li><p>NodeTransitionFunction: This instantiates the functions f(·) and g(·) from Equations (1) and (2) respectively.</p>
</li>
<li><p>Node: This represents a node in the network; it is where the core functionality of the assignment is. Nodes receive messages, determine the next one to forward them to, and carry out the forwarding, among other functions. A node will have an integer ID 0 . . . N − 1, where N is the number of nodes a particular network.</p>
</li>
<li><p>Network: This represents a network of nodes. The key component of the network is a lookup table that is accessible to all nodes, so that nodes can look up properties of other nodes. The table has the form<br><code>Map&lt;Integer,Node&gt; lookup;</code><br>It also contains functions that will be provided for reading network speciﬁcations and messages from ﬁles.</p>
</li>
<li><p>MessageTrackCheck: This represents an encoded trail of which nodes were visited in the process of passing messages. (It is mostly just used in the JUnit tests.)</p>
</li>
</ul>
<p>For your tasks, you’ll be adding attributes and methods to existing classes given in the code bundle accompanying these specs. Where it’s given, you should use exactly the method stub provided for implementing your tasks. Don’t change the names or the parameters or exception handling. You can add more functions if you like.</p>
<h5 id="Pass-Level"><a href="#Pass-Level" class="headerlink" title="Pass Level"></a>Pass Level</h5><p>To achieve at least a Pass (≥ 50%) for the assignment, you should do all of the following.</p>
<p>There will be some sample input ﬁles to be used in the JUnit tests in the code bundle. The sample input nodedef1.in consists of 20 nodes, each with associated trapdoor function parameters e = 3, d = 7, K = 33. Obviously in a real network nodes would have diﬀerent parameter values, and in later input ﬁles they will; it just happens that this triple is the smallest one that works for this kind of trapdoor function, and so the easiest to handle numerically when getting started.</p>
<p>There will be no public Node method to ﬁnd out which node sent a message to the current node. (If there was, there would be no anonymity. However, we will change this slightly for corrupt nodes in the Distinction level tasks.) On the other hand, we want some way of recording which nodes were visited.</p>
<p>The MessageTrackCheck class acts a like a parity check, and works as follows. A MessageTrackCheck instance t will sum the IDs of each node that is involved in passing a message, including the initiator and receiver; it will also add a speciﬁed oﬀset. It will then internally calculate the sum mod 26, and make available the corresponding check character from the lower-case alphabet a . . . z, assuming they are indexed by the values 0 . . . 25 respectively.</p>
<p>So if a message track check has an oﬀset of 3, and a message is passed along a path of nodes 1 → 4 → 10 → 6, the check character would be the character corresponding to (3 + 1 + 4 + 10 + 6) mod 26 = 24, which is y.</p>
<p>Write the following methods for class MessageTrackCheck.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageTrackCheck</span><span class="params">(Integer offset)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// CONSTRUCTOR: Argument is offset to initialise the running sum </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Adds n to the running sum </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">check</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns the character that corresponds to the running sum mod 26; </span></span><br><span class="line">    <span class="comment">// 0..25 correspond to a..z </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Integer offset)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Re-initialises the running sum to the given offset </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Write the following methods for the NodeTransitionFunction class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeTransitionFunction</span><span class="params">(Integer exp, Integer KVal)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// CONSTUCTOR: Sets the class to calculate f(x) = (x ^ exp) mod KVal </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer val)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Implements f(val) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that if you implement apply() in a straightforward way, you will almost certainly exceed Java’s Integer.MAX_VALUE: try it for yourself with an instance of NodeTransitionFunction instantiated with values 3 and 33, comparing it against the value obtained from e.g. a spreadsheet.</p>
<p>Instead, there is a useful identity that lets you make the calculation without this risk:</p>
<p>$$(ab) mod p = ((a mod p)(b mod p)) mod p$$</p>
<p>Implement apply() using this identity. </p>
<p>Implement a constructor for class Node with the following signature:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer n, Integer e, Integer d, Integer K, Boolean encrypt, Boolean useBI, Map&lt;Integer,Node&gt; m, MessageTrackCheck t)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// CONSTUCTOR:</span></span><br><span class="line">    <span class="comment">// n is node ID, </span></span><br><span class="line">    <span class="comment">// e is the exponent for the function f() </span></span><br><span class="line">    <span class="comment">// d is the exponent for the function g() </span></span><br><span class="line">    <span class="comment">// K is the divisor in f() and g() </span></span><br><span class="line">    <span class="comment">// encrypt is true if messages are encrypted, false otherwise </span></span><br><span class="line">    <span class="comment">// useBI is true if BigInteger should be used for NodeTransitionFunction, false otherwise </span></span><br><span class="line">    <span class="comment">// m is a non-null map of node IDs to node objects </span></span><br><span class="line">    <span class="comment">// t is an instance of MessageTrackCheck </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For the Pass level, encrypt and useBI will be set to false. The parameters e, d and K here correspond to the e, d, K from §2.2.</p>
<p>This task and those below all involve adding to class Node.</p>
<p>For the Pass level, when a message is passed through the network it will have appended to the end a 3-character string that indicates the destination; we will call this combination of the original message and destination the augmented message. A node will therefore know that it is the destination for a message from the ﬁnal three characters of the augmented message. An augmented message that has the value hello006 is thus destined for node 6.</p>
<p>Implement the following method in class Node:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isDestinationNode</span><span class="params">(String msg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is an augmented message (i.e. containing 3 characters at the end </span></span><br><span class="line">    <span class="comment">// indicating destination node) </span></span><br><span class="line">    <span class="comment">// POST: Returns true if this is the destination node, false otherwise </span></span><br><span class="line">    <span class="comment">// E.g. For node 6, will return true for "hello006" </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are several getter methods for class Node:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getID</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns node ID </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getE</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns value of e in this node’s function f() </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getK</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns value of K in this node’s function f() </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">transmittedMessage</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns true if this node has transmitted a message, false otherwise </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns the current received (non-augmented) message, null if no received message </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A node will have its own NodeTransitionFunction that corresponds to function f(·) as deﬁned by its own parameters e, K.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NodeTransitionFunction <span class="title">createForwardNodeTransitionFunction</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Creates a NodeTransitionFunction using this node’s public function f() </span></span><br><span class="line">    <span class="comment">// with parameters e, K </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>All nodes have the core functionality of receiving and sending messages. For a node at step i in a path of length n, in sending a message it passes along the payload consisting of the (augmented) message, the value r i , and the node transition function representing a particular f(·) that the next node will use. In our example from §2.2, for the node 1 at the ﬁrst step in the path, it will be sending to node 4, the value of r is 24, and the node transition function is f(·) with e = 3, K = 33.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgToNode</span><span class="params">(Node n, String msg, Integer r, NodeTransitionFunction f)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: n is a non-null node, </span></span><br><span class="line">    <span class="comment">// msg is an (augmented) message, </span></span><br><span class="line">    <span class="comment">// r is the current value of r from the forward transition function.</span></span><br><span class="line">    <span class="comment">// f is the forward transition function </span></span><br><span class="line">    <span class="comment">// POST: invokes receiveMsgFromNode on node n </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following method speciﬁes what happens when a node receives a message. Continuing the example, when node 4 receives the message from node 1, say the augmented message is hello006: node 4 is then not the destination. So it takes the value r = 24 and calculates the next node to forward the message to, f(24).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsgFromNode</span><span class="params">(String msg, Integer id, Integer r, NodeTransitionFunction f)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is an augmented message, </span></span><br><span class="line">    <span class="comment">// id is the ID of the sending node, </span></span><br><span class="line">    <span class="comment">// r is the current value of r from the forward transition function, </span></span><br><span class="line">    <span class="comment">// f is the forward transition function </span></span><br><span class="line">    <span class="comment">// POST: If this is the destination node, stop; </span></span><br><span class="line">    <span class="comment">// otherwise, send the message onwards.</span></span><br><span class="line">    <span class="comment">// Add ID of current (receiving) node to local MessageTrackCheck </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>An initiator has some additional functionality. First, there is a method to construct an augmented message from the original message:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addDestIDToMsg</span><span class="params">(String msg, Integer v)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is a message, v is a node ID </span></span><br><span class="line">    <span class="comment">// POST: Returns a string that concatenates v as a 3-character string to the end of msg. </span></span><br><span class="line">    <span class="comment">// E.g. for msg="hello", v=6, returns "hello006" </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then, it has to calculate the value r 1 to determine which the ﬁrst node is to send the message to, as described in §2.2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">firstRForInitiatingMessage</span><span class="params">(Integer k, Integer v)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: v is destination node ID, k is number of steps </span></span><br><span class="line">    <span class="comment">// POST: Uses the trapdoor function inverse, applied to destination node v with number of steps k, </span></span><br><span class="line">    <span class="comment">// to calculate the node path; </span></span><br><span class="line">    <span class="comment">// returns value of r that determines first step on node path </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then, it has to initiate the sending of the message; this involves creating the function f(·) using its own parameters e, K that can be passed along to later nodes in the path.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initiateMessage</span><span class="params">(String msg, Integer k, Integer v)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is an original message, v is destination node ID, k is number of steps </span></span><br><span class="line">    <span class="comment">// POST: Adds destination ID to msg; </span></span><br><span class="line">    <span class="comment">// sends augmented msg to the next node, as determined by firstRForInitiatingMessage(k, v), </span></span><br><span class="line">    <span class="comment">// along with new forward transition function </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Credit-Level"><a href="#Credit-Level" class="headerlink" title="Credit Level"></a>Credit Level</h5><p>To achieve at least a Credit (≥ 65%) for the assignment, you should do the following. completed all the Pass-level tasks.</p>
<p>You should also have </p>
<p>For Credit-level tasks and above, it will be up to you to discover how some more advanced Java features work. It will be OK to ask questions, but you’ll be expected to read Java documentation yourself ﬁrst.</p>
<p>In the Credit-level tasks, you’ll be using Java’s BigInteger 9 for calculations of f(·) and g(·). This class has been speciﬁcally designed for dealing with problems like the Integer.MAX_VALUE one noted in the Pass-level tasks.</p>
<p>In class NodeTransitionFunction, add a new method apply() that takes its argument as a BigInteger rather than an Integer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">apply</span><span class="params">(BigInteger val)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Implements f(val), with val as a BigInteger </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can, and should, still keep your earlier apply() method. From Java’s point of view, the type signatures of these methods are diﬀerent, and it will know which one to invoke by the argument.</p>
<p>Add the following methods to class Node that duplicate several methods from the Pass-level tasks but that use BigInteger rather than Integer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgToNode</span><span class="params">(Node n, String msg, BigInteger r, NodeTransitionFunction f)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: n is a non-null node, </span></span><br><span class="line">    <span class="comment">// msg is an augmented message, </span></span><br><span class="line">    <span class="comment">// r is the current value of r from the forward transition function.</span></span><br><span class="line">    <span class="comment">// f is the forward transition function </span></span><br><span class="line">    <span class="comment">// POST: invokes receiveMsgFromNode on node n </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsgFromNode</span><span class="params">(String msg, Integer id, BigInteger r, NodeTransitionFunction f)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is an augmented message, </span></span><br><span class="line">    <span class="comment">// id is the ID of the sending node, </span></span><br><span class="line">    <span class="comment">// r is the current value of r from the forward transition function.</span></span><br><span class="line">    <span class="comment">// f is the forward transition function </span></span><br><span class="line">    <span class="comment">// POST: If this is the destination node, stop; </span></span><br><span class="line">    <span class="comment">// otherwise, send the message onwards.</span></span><br><span class="line">    <span class="comment">// Add ID of current (receiving) node to local MessageTrackCheck </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">firstRForInitiatingMessage</span><span class="params">(Integer k, BigInteger v)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: v is destination node ID, k is number of steps as a BigInteger </span></span><br><span class="line">    <span class="comment">// POST: Uses the trapdoor function inverse, applied to destination node v with number of steps k, </span></span><br><span class="line">    <span class="comment">// to calculate the node path; </span></span><br><span class="line">    <span class="comment">// returns value of r that determines first step on node path </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that you’ll also want to change the internals of initiateMessage(), depending on whether useBI is set to true or false in the node constructor.</p>
<h5 id="High-Distinction-Level"><a href="#High-Distinction-Level" class="headerlink" title="(High) Distinction Level"></a>(High) Distinction Level</h5><p>To achieve at least a Distinction (75−100%) for the assignment, you should do the following. You should also have completed all the Credit-level tasks.</p>
<p>There are two aspects to these advanced level tasks.</p>
<p>Corrupt Nodes The ﬁrst is implementing a simpliﬁed version of how a corrupt node might try to guess an initiator. For this, a corrupt node will assume that there is only one initiator in the network. A corrupt node forwards and receives messages just like any other node, but keeps track of which node sent it a message. Further, a corrupt node $v_{c 1}$ can ﬁnd out from another corrupt node $v_{c2}$ which node $v_p$ most recently sent $v_{c2}$ a message; that node $v_p$ could likewise be corrupt, and $v_{c1}$ could then query $v_p$ as well.</p>
<p>We will stipulate that a corrupt node $v_{c1}$ guesses another node $v_g$ to be a message initiator if it discovers that $v_g$ has transmitted messages that have reached $v_{c1}$ along two diﬀerent paths. ($v_{c1}$ does not have to be the receiver; it may have just forwarded the message.)</p>
<p>Consider an example that extends from §2.2. We have the same network with nodes 0 . . . 19, and initiator node v 0 = 1. In this example, v 0 sends a ﬁrst message with path length 2 to node v 2 = 8; the path will be 1 → 2 → 8. 0 Then it sends a second message with path length 4 to node $v_4 = 7$; the path will be 1 → 13 → 19 → 8 → 7.</p>
<p>Assume that nodes 2, 8, 13 and 19 are corrupt. Node 8 can then guess that node $v_0 = 1$ is the initiator. If the set of nodes that are corrupt were instead {2, 8, 19}, it could not be guessed.</p>
<p>Write the following methods in class Node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorrupt</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Sets a node to be corrupt </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">lastSender</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: If a node is not corrupt, returns -1; </span></span><br><span class="line">    <span class="comment">// if a node is corrupt, returns ID of node that last sent it a message, </span></span><br><span class="line">    <span class="comment">// -1 if it has not been sent any messages </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">guessInitiator</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Guesses a node to be the initiator if it can track back through corrupted nodes </span></span><br><span class="line">    <span class="comment">// along two separate paths; </span></span><br><span class="line">    <span class="comment">// returns this node ID, or -1 if no guess </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Encryption In the second part of the advanced level, you’ll be working with actual encrypted messages. Specifically, we will use ElGamal encryption 11 as speciﬁed in Rass and Wigoutschnigg [2016]. As with encryption in general, this involves a public key and a private key. When an initiator node v 0 wants to send a message to a receiver node v, it will use v’s public key to encrypt the message; then only v can decrypt it, using its private key.</p>
<p>Determining whether a node is the destination or not is thus diﬀerent from the earlier levels: there is no longer an augmented message of type String where the last 3 characters give the destination. Instead, we will implement it as described in Rass and Wigoutschnigg [2016]. First, the initiator uses a hash function on the original message, and then concatenates this hash value (which for us will be 3 characters long) to form an augmented message; it then encrypts this augmented message using the receiver’s public key. It sends this encrypted message as usual.</p>
<p>Each node along the path to the receiver tries to decrypt the encrypted message with its own private key. Treating the decryption as a String, it hashes the ﬁrst n − 3 characters and compares it to the last 3 characters of the decryption. If it is the correct private key, these will match; if it is not, the decryption will look like gobbledygook rather than a valid string, and the hashes will not match.</p>
<p>There are a number of sample programs you can ﬁnd on the Internet which use the same mechanisms we will use. 12 The cryptography libraries are part of javax.crypto.Cipher; to import this, you’ll have to add some external libraries (made available in iLearn) to the project. </p>
<p>You then need to implement the following methods in class Node</p>
<p>The following are some getter methods.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">hasMsgEncryption</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Returns true if messages are encrypted, false otherwise </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">getPublicKey</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE:</span></span><br><span class="line">    <span class="comment">// POST: Returns the node’s public key (null if hasMsgEncryption() is false) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Do this by right-clicking on your project in Eclipse and selecting Properties – Java Build Path – Libraries – Add External JARs.</p>
<p>The following methods are related to the new deﬁnition of augmented messages.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">basicHashFunction</span> <span class="params">(String m)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: </span></span><br><span class="line">    <span class="comment">// POST: Sums the numeric value of each character using Character.getNumericValue(), </span></span><br><span class="line">    <span class="comment">// takes mod 100 of the total; returns as a 3-char string </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>An an example, the basic hash function when applied to string hello should return the string 097.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addCheckToMsg</span><span class="params">(String msg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is a message </span></span><br><span class="line">    <span class="comment">// POST: Returns a string that concatenates the basicHashFunction of msg </span></span><br><span class="line">    <span class="comment">// E.g. for msg="hello", returns "hello097" </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following methods are the heart of the message encryption process.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] encryptedMsg(String msg, Key chosenPubKey) &#123; </span><br><span class="line">    <span class="comment">// PRE: msg is a message, chosenPubKey is a public key </span></span><br><span class="line">    <span class="comment">// POST: Returns msg encrypted with chosenPubKey </span></span><br><span class="line">    <span class="comment">// (null if hasMsgEncryption() is false or chosenPubKey is null) </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] decryptedMsg(<span class="keyword">byte</span>[] msg) &#123; </span><br><span class="line">    <span class="comment">// PRE: msg is an encrypted message as a byte array </span></span><br><span class="line">    <span class="comment">// POST: Returns msg decrypted using node’s private key </span></span><br><span class="line">    <span class="comment">// (null if hasMsgEncryption() is false) </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isDestinationNode</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// PRE: msg is an augmented encrypted message (i.e. containing 3 check digits at the end) </span></span><br><span class="line">    <span class="comment">// POST: Returns true if this is the destination node, false otherwise.</span></span><br><span class="line">    <span class="comment">// Determines if this is the destination by decrypting msg, // then comparing the hashed decrypted core msg (i.e. up to the last 3 //// characters) </span></span><br><span class="line">    <span class="comment">// against the last 3 chars of the decrypted msg </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that to fully implement encrypted messages, you’d also have to deﬁne new functions sendMsgToNode() and recMsgFromNode() so that their message arguments were of type byte[] rather than String, and change the internals of several other functions. However, you don’t have to do this for the assignment. Only the above functions will be tested in the JUnit tests.</p>


            <!-- Tags -->
            


<div class="tags">
    <a href="/tags/JAVA/">JAVA</a> <a href="/tags/算法/">算法</a>
</div>



            <!-- Comments -->
            <div>
                




            </div>
        </div><!-- end content -->
    </section>
</section><!-- end main -->

<!-- After footer scripts -->

<!-- jQuery -->
<script src="/js/jquery.js"></script>

<!-- Custom Code -->
<script src="/js/main.js"></script>

<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>